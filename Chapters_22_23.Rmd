---
title: "Capítulos 22 y 23"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

<br><br><br><br>

### **Capítulo 22:** Introducción a Modelado

<br><br><br><br>

###  Usted está _aquí_

![](figures\ch22_1.jpg)

***

### Generalidades

* El objetivo de un modelo es proveer un resumen de baja dimensión (poquitas variables) de una base de datos.

* Idealmente, un modelo:

1. Captura señales verdaderas (patrones generados por el fenómeno en estudio)

2. Ignora ruido (variación azarosa que no nos interesa)

* Vamos a estar viendo modelos predictivos (tambien se los nombra supervisados, ponele).


***

### Qué se incluye en este "Usted está aquí" de Modelado

* Capítulos 23 a 25 buscan construir la intuición de cómo funcionan estos modelos estadísticos.

* Modelado Básico (Capi 23, hoy): cuestiones mecánicas sobre modelos lineales usando datos simulados (no reales).

* Construcción de modelos (Capi 24, en dos domingos): formas para extraer patrones de datos reales.

* En el capítulo 25 vamos a ver muchos modelos simples para entender bases de datos complejas.

* Todos los contenidos serán sobre todo cualitativos (no habrá herramientas para cuantificar cuán bueno es un modelo).


***

### Conceptos claves importantes para la vida (datera)

* Cada observación puede ser usada para explorar los datos (análisis exploratorio, generación de hipótesis) o para confirmar una hipótesis (análisis inferencial) - *nunca ambas*.

* Usa tus observaciones tantas veces como quieras para explorar tus datos. Usála sólo una vez para confirmar algo.

* Tan pronto como usas un dato dos veces, acabás de pasar del marco confirmatorio al exploratorio (pero no hay warning de RStudio que te salve en esta).

* Si no usas distintos datos para generar una hipotesis y para confirmarlas, vas a pecar de optimista (sobreajuste)

* Si presentás un modelo exploratorio como uno confirmatorio vas a estar contribuyendo a la crisis de replicabilidad de la ciencia :-P


***

### Tips para no meter la pata en la vida (datera)

* Una forma  (de muchas) para no meter la pata es dividir tus datos en distintos conjuntos:

1. Set de entrenamiento (training, para exploración), quizás 60% de tus datos

2. Set para comparar modelos o visualizaciones en forma manual (query set). Para chequear algunas hipotesis generadas con el training set.

3. Set de prueba (testing set). Lo usarás sólo una vez, para poner a prueba el modelo final.

* Nota: igual un análisis descriptivo _siempre_ hay que hacerle al testing set.

<br><br><br><br>

### **Capítulo 23:** Modelado básico

<br><br><br><br>

###  Intro

* Vamos a usar modelos matemáticos para representar los datos como patrones y el resto, los residuales - que muchas veces solo representan ruido.

* En este capítulo se usarán solo datos simulados, simples y sin interés práctico, pero que ayudan a entender la esencia del modelado.

***

### El modelo y sus partes

* Parte 1: Familia de modelos. La expresamos en forma generica como, por ejemplo:

1. $y = a_1 * x + a_2$ (modelo lineal) o 
2. $y = a_1 * x ^ {a_2}$ (modelo no lineal)

En estos modelos $x$ e $y$ son columnas de nuestros datos tidy y $a_1$ y $a_2$ son parámetros que cambian para capturar distintos patrones en los datos.


* Parte 2: Modelo ajustado (fitted). El modelo de la familia que es más cercano a los datos (cercano definido de alguna forma, hay muchas formas). El modelo ajustado tiene formas específicas tales como:

1. $y = 3 * x + 7$ (modelo lineal) o 
2. $y = 9 * x ^ 2$ (modelo cuadrático)

El modelo ajustado es el modelo más cercano a los datos de toda la familia. Es el "mejor" modelo en cuanto a cercanía. Esto *nunca* implica que el modelo sea bueno o útil. Podrías tener el mejor de los peores.

***

Un modelo no busca revelar la verdad, si no descubrir una aproximación simple que sea útil.

***

### Paquete `modelr`

Este paquete anda lindo con funciones de modelado de R base y permite que usemos ` %>% `.

```{r 2311, message=FALSE}

library(tidyverse)

library(modelr)

options(na.action = na.warn)
```

***

### Un modelito tranca

```{r 232, message=FALSE}

ggplot(sim1, aes(x, y)) + # sim1 viene con modelr
  geom_point()
```

Que patron tiene este modelo lineal? (versión dominguera del color del caballo blanco de San Martín - sí, me tragué un payaso)

***

### Juguemos un toque a ver cómo podemos generar un modelo lineal

Es decir, un modelo de esta familia $y = a_0 + a_1 * x$.


```{r 2321, message=FALSE}

# armamos un tibble con la columna a1 y la columna a2 generadas al azar como dos variables uniformes, una va entre -20 y 40 y la otra entre -5 y 5 Al ser uniformes, la probabilidad de que salga cualquiera de los numeros en ese rango es la misma
models <- tibble(
  a1 = runif(250, -20, 40),
  a2 = runif(250, -5, 5)
)

# Al grafico de los puntos iniciales, le agregamos rectas al azar con ordenada al origen a1 y pendiente a2. Un bardito.
ggplot(sim1, aes(x, y)) + 
  geom_abline(aes(intercept = a1, slope = a2), data = models, alpha = 1/4) +
  geom_point() 

```

* Hay 250 líneas (modelos) en el gráfico, una por cada $a_1$ y $a_2$ generadas. 

* Hay un montón de líneas uqe no tienen nada que ver con los puntos de los datos `sim1`. 

* Qué significa exactamente estar cerca de los datos?

* Una forma de estar cerca podría ser encontrar la línea con $a_1$ y $a_2$ cuya distancia vertical a cada punto de `sim1` sea mínima. Como en esta figura (hay líneas torcidas para que se vean todas).

***

![](figures\ch23_1.jpg)

* La línea azul representa la diferencia entre el valor de $y$ dado por el modelo (predicción) y cada punto en `sim1`.

***

### Mínimos Cuadrados a Manopla

* Pocas cosas mejores que programar un método para entender de qué se trata. Vamos a tratar de encontrar la mejor línea usando código.

* *Paso 1.* usando dos posibles $a_1$ y $a_2$, generar predicciones para los 30 pares de datos en `sim1`.

```{r 2322, message=FALSE}

model1 <- function(a, data) {
  a[1] + data$x * a[2]
}
model1(c(7, 1.5), sim1)

```

* *Paso 2.* Calculamos las distancias entre cada punto en `sim1` y estas predicciones

* *Paso 3.* Colapsamos las 30 distancias en un solo número. Una forma matemáticamente bonita y conveniente de hacerlo es elevando cada diferencia al cuadrado y tomando el promedio de la suma de esos cuadrados y sacando la raíz cuadrada de ese promedio (error cuadrático medio)

```{r 2323, message=FALSE}

measure_distance <- function(mod, data) {
  diff <- data$y - model1(mod, data)
  sqrt(mean(diff ^ 2))
}
measure_distance(c(7, 1.5), sim1)
```

* *Paso 4.* Repetimos 1 a 3 para cada uno de los 250 modelos que generamos en `models`

```{r 2324, message=FALSE}

sim1_dist <- function(a1, a2) {
  measure_distance(c(a1, a2), sim1)
}

# usamos purrr con la helper function sim1_dist que toma 2 parametros double
models <- models %>% 
  mutate(dist = purrr::map2_dbl(a1, a2, sim1_dist))
models
```

* *Paso 5, primer intento.* Queremos encontrar la mejor recta (la más cercana a los datos) veamos qué pinta tienen los 10 modelos con menor `dist`


```{r 2325, message=FALSE}

ggplot(sim1, aes(x, y)) + 
  geom_point(size = 2, colour = "grey30") + 
  geom_abline(
    aes(intercept = a1, slope = a2, colour = -dist), 
    data = filter(models, rank(dist) <= 10)
  )
```

* *Paso 5, segundo intento.* También podemos graficar todas los pares $a_1$ y $a_2$, colorear por `-dist` y marcar los 10 pares con la menor `dist`

```{r 2326, message=FALSE}

ggplot(models, aes(a1, a2)) +
  geom_point(data = filter(models, rank(dist) <= 10), size = 4, colour = "red") +
  geom_point(aes(colour = -dist))
```

* *Paso 5, mejorado.* Combinamos el Paso 4 y el 5 pero en lugar de hacerlo con modelos al azar, lo hacemos de una forma sistemática buscando los parámetros en una grilla de parámetros distribuidos uniformemente (grid search).

```{r 2327, message=FALSE}

# los parametros para la grilla salen de mirar el grafico anterior y ver donde estaban los mejores parámetros
# expand.grid es una funcion de R base que crea un dataframe de todas las combinaciones de dos factores
grid <- expand.grid(
  a1 = seq(-5, 20, length = 25),
  a2 = seq(1, 3, length = 25)
  ) %>% 
  mutate(dist = purrr::map2_dbl(a1, a2, sim1_dist))

grid %>% 
  ggplot(aes(a1, a2)) +
  geom_point(data = filter(grid, rank(dist) <= 10), size = 4, colour = "red") +
  geom_point(aes(colour = -dist)) 

```

Cómo les va con los datos a estos 10 mejores pares de parámetros?

```{r 2328, message=FALSE}

ggplot(sim1, aes(x, y)) + 
  geom_point(size = 2, colour = "grey30") + 
  geom_abline(
    aes(intercept = a1, slope = a2, colour = -dist), 
    data = filter(grid, rank(dist) <= 10)
  )

```

* *Paso 5, intento final.* Podrías repetir el intento final haciendo la grilla cada vez más fina hasta que encontrás el mejor modelo. Hay un algoritmo que lo hace llamado búsqueda de Newto-Raphson y que está implementado en la funcion `optim()` del paquete `stats` en R base.

```{r 2329, message=FALSE}

best <- optim(c(0, 0), measure_distance, data = sim1)
best$par

ggplot(sim1, aes(x, y)) + 
  geom_point(size = 2, colour = "grey30") + 
  geom_abline(intercept = best$par[1], slope = best$par[2])
```

La intuicion detras de `optim()` es que si tenes:

* una función que define la distancia entre un modelo 
* un set de datos 
* un algoritmo que puede minimizar la distancia modificando los parámetros del modelo

podés encontrar el mejor modelo. 

La belleza de esto es que esto lo podés usar para cualquier familia de modelos para los que puedas escribir una ecuación.

* *Paso 5, intento final usando matemática.* $y = a_1 + a_2 * x$ es un modelo lineal y en estos casos R tiene la función `lm()` para ajustarlo

```{r 23210, message=FALSE}
# lm() usa formulas, en este caso y ~ x es la forma de escribir y = a_1 + a_2 * x
sim1_mod <- lm(y ~ x, data = sim1)
coef(sim1_mod)
```

Obtenemos al segundo decimal lo mismo que con `optim()`.  `lm()` es mucho mas rapido y mejor porque resuelve todo en un solo paso y garantiza que encuentra el mejor modelo. Usa una formula matematica que se puede derivar para los modelos lineales. La mayoria de los modelos no tienen estas formulas o a veces calcularlas es dificil y se termina usando algo como `optim()`.

***

### Visualizando un modelo a través de sus predicciones


* Mirar un modelo a través de sus predicciones tiene la ventaja de que lo podés hacer para cualquier modelo predictivo - incluso los que tienen ecuaciones difíciles de dibujar en dos o tres dimensiones.

* Usando `modelr::data_grid()` se puede generar una grilla de valores que cubra la region donde viven los datos que observamos - en este caso `sim1`

```{r 2331, message=FALSE}
grid <- sim1 %>% 
  data_grid(x) 
grid
```

La salida es mucho mas interesante cuando tenemos mas variables en nuestro modelo.

A esta grilla le agregamos predicciones usando `modelr::add_predictions()` usando el modelo `sim1_mod`.

```{r 2332, message=FALSE}
grid <- grid %>% 
  add_predictions(sim1_mod) 
grid
```

Y ahora podemos graficar las predicciones sobre nuestros datos originales.

```{r 2333, message=FALSE}
ggplot(sim1, aes(x)) +
  geom_point(aes(y = y)) +
  geom_line(aes(y = pred), data = grid, colour = "red", size = 1)
```

Pará, pará, pará... pero no es más fácil hacerlo con `geom_abline()`? Sí, cuando tu modelo tiene una ordenada al origen y una pendiente, pero modelos más complicados no tienen sólo dos parámetros, tienen un montón. Siempre podés visualizar sus predicciones y ver cómo funcionan para tus datos.

***

### Visualizando un modelo a través de sus residuos

* La otra cara de las predicciones son los residuales.

* Las predicciones nos dicen qué patrones capturó el modelo.

* Los residuales nos dicen qué patrones no capturó.

* Son las distancia entre los datos observados y los valores predichos por el modelo.

* Si nuestro modelo capturó todos los patrones, los residuales no deberían mostrarnos ningún patrón y estar, en promedio cerca de 0 y no muy lejos de los valores observados.

```{r 2334, message=FALSE}
# add_residuals de modelr agrega residuales
sim1 <- sim1 %>% 
  add_residuals(sim1_mod)
sim1
```

Con un polígono de frecuencias podemos entender cómo se distribuyen los residuales.

```{r 2335, message=FALSE}
ggplot(sim1, aes(resid)) + 
  geom_freqpoly(binwidth = 0.5)
```

Otra forma de ver los residuales es ver cómo se relacionan con los predictores en nuestro modelo.

```{r 2336, message=FALSE}
ggplot(sim1, aes(x, resid)) + 
  geom_ref_line(h = 0) +
  geom_point()
```

Si hay ningún patrón cuando graficamos los predictores en funcion de los residuos, quiere decir que no nos quedaron patrones por aprender y que el modelo que tenemos capturó toda la información que había en los datos.
 

***

### Un chapuzón al mundo de las fórmulas en R

* Las fórmulas en R, esos enunciados que incluyen un `~`, nos ofrecen una forma de capturar la estructura de variables que las funciones de R pueden interpretar.

* Para ver qué es lo que R hace realmente cuando le decimos `y ~ x` para representar $y = a_1 + a_2 * x$, podemos usar `modelr::model_matrix()`.

```{r 2341, message=FALSE}
df <- tribble(
  ~y, ~x1, ~x2,
  4, 2, 5,
  5, 1, 6
)
model_matrix(df, y ~ x1 + x2)
```

* Notá que para representar la ordenada al origen, R agrega una columna de unos. Si no la querés, hay que pedirle explícitamente que la saque usando `-1`.

```{r 2342, message=FALSE}
model_matrix(df, y ~ x1 + x2 - 1)
```

***

### Fórmulas con variables categóricas - angora te quiero ver

* A la hora de las fórmulas las variables categóricas nos pueden complicar un poco la existencia, comparadas con la papa que son las variables continuas.

* Las variables categóricas no son números, no tiene sentido multiplicarlas. A ver, no tiene sentido algo del estilo $y = x_0 + x_1 * color$ donde `color` toma los valores verde y violeta. Un número multiplicado por verde no nos va a dar un número para $y$. 

* Lo que hace R es convertir $y = x_0 + x_1 * color$ a $y = x_0 + x_1 * colorvioleta$, en donde `colorvioleta` es 1 si `color` es violeta y 0 si no.

```{r 2343, message=FALSE}
df <- tribble(
  ~ color, ~ response,
  "verde", 1,
  "violeta", 2,
  "verde", 1
)
model_matrix(df, response ~ color)
```

* Y por qué no ponemos una columna `colorverde` también? Porque agregamos información redundante - $ colorverde = 1 - colorvioleta$, si sabemos el valor de `colorvioleta` deducimos, sin info extra, el valor de `colorverde`.

* Al agregar info redundante la estimación de nuestros $x_0$ y $x_1$ no va a ser único y se nos complica la vida al pepe.

***

### Modelo lineal con una predictora categórica con cuatro valores posibles (o niveles)

```{r 2344, message=FALSE}
# la base sim2 es de modelr
ggplot(sim2) + 
  geom_point(aes(x, y))
```

R usa la siguiente matriz para x (xb, xc, xd - 4 categorias menos 1):

```{r 2347, message=FALSE}
model_matrix(sim2, y ~ x)
```

Le ajustamos un modelo lineal a `sim2` y vemos sus predicciones:

```{r 2345, message=FALSE}
mod2 <- lm(y ~ x, data = sim2)

grid <- sim2 %>% 
  data_grid(x) %>% 
  add_predictions(mod2)
grid
```

El modelo lineal predice la media de cada categoría de $x$ porque la media minimiza el error cuadrático medio. No es magia, es matemática.

```{r 2346, message=FALSE}
ggplot(sim2, aes(x)) + 
  geom_point(aes(y = y)) +
  geom_point(data = grid, aes(y = pred), colour = "red", size = 4)
```

Ojo con querer hacerle predecir para una clase de la categoría que no estaba en los datos originales:

```{r 2348, eval=FALSE, message=FALSE, include=FALSE}
tibble(x = "e") %>% 
  add_predictions(mod2)
```


***

### Modelo lineal con una predictora categórica y una continua

Usamos `sim3`

```{r 2349, message=FALSE}
ggplot(sim3, aes(x1, y)) + 
  geom_point(aes(colour = x2))
```

Podemos ajustarle dos modelos que incluyan ambas predictoras:

```{r 23410, message=FALSE}
mod1 <- lm(y ~ x1 + x2, data = sim3)
mod2 <- lm(y ~ x1 * x2, data = sim3)
```

* `y ~ x1 + x2` es $y = a_0 + a_1 * x_1 + a_2 * x_2 $

* `y ~ x1 * x2` es $y = a_0 + a_1 * x_1 + a_2 * x_2 + a_{12} * x_1 * x_2$

Generemos predicciones para estos modelos y veamos cómo les va:

```{r 23411, message=FALSE}
grid <- sim3 %>% 
# a data_grid hay que pasarle las dos predictoras para que genere valores para las combinaciones de ambas variables
   data_grid(x1, x2) %>%
# gather_predictions genera predicciones para ambos modelos y los pone en una sola columna. Tiene a su amiga spread_predictions que las pone en una columna para mod1 y otra para mod2
  gather_predictions(mod1, mod2)
grid
```

Miramos la pinta de las predicciones:

```{r 23412, message=FALSE}
ggplot(sim3, aes(x1, y, colour = x2)) + 
  geom_point() + 
  geom_line(data = grid, aes(y = pred)) + 
  facet_wrap(~ model)
```

* En el modelo que usa $+$ las rectas tienen la misma pendiente, no así en la que usa $*$.

* Cuál de los dos modelos será mejor? Veamos si los residuales de cada modelo nos pueden dar una pista

```{r 23413, message=FALSE}
sim3 <- sim3 %>% 
  gather_residuals(mod1, mod2)

ggplot(sim3, aes(x1, resid, colour = x2)) + 
  geom_point() + 
  facet_grid(model ~ x2)
```

* El gráfico nos permite ver que `mod1` se dejó un patrón en los residuos para $x_2 = b$, $x_2 = c$ y $x_2 = d$

* Formas cuantitativas de comparar modelos quedan fuera del alcance del libro 

***

### Y si tengo dos predictoras continuas?

Usamos `sim4`. Misma cosa que al comienzo de la sección anterior para ajustar los dos modelos posibles.

```{r 23414, message=FALSE}
mod1 <- lm(y ~ x1 + x2, data = sim4)
mod2 <- lm(y ~ x1 * x2, data = sim4)

grid <- sim4 %>% 
  data_grid(
    x1 = seq_range(x1, 5), 
    x2 = seq_range(x2, 5) 
  ) %>% 
  gather_predictions(mod1, mod2)
grid
```

* Un detalle de este código es el uso de `modelr::seq_range()` dentro de `data_grid()`.

* En lugar de usar cada valor único de $x$, `seq_range` permite usar una grilla de 5 valores regularmente distribuidos entre el minimo y máximo de $x$.

* `seq_range() tiene opciones interesantes como `pretty = TRUE`,

```{r 23415, message=FALSE}
seq_range(c(0.0123, 0.923423), n = 5)
seq_range(c(0.0123, 0.923423), n = 5, pretty = TRUE)
```

* `trim = 0.1` - que corta los valores de las colas más allá del 10% para variables con cola larga y cuando nos interesa hacer foco en los valores más centrales.

```{r 23416, message=FALSE}
x1 <- rcauchy(100)
seq_range(x1, n = 5)
seq_range(x1, n = 5, trim = 0.10)
seq_range(x1, n = 5, trim = 0.25)
seq_range(x1, n = 5, trim = 0.50)
```

* y `expand = 0.1` que es como el opuesto de trim

```{r 23417, message=FALSE}
x2 <- c(0, 1)
seq_range(x2, n = 5)
seq_range(x2, n = 5, expand = 0.10)
seq_range(x2, n = 5, expand = 0.25)
seq_range(x2, n = 5, expand = 0.50)
```

Digresión aparte, tratemos de ver qué onda las predicciones de los modelos:

```{r 23418, message=FALSE}
ggplot(grid, aes(x1, x2)) + 
  geom_tile(aes(fill = pred)) + 
  facet_wrap(~ model)
```

Mirados desde arriba, nuestros modelos son dos superficies que a priori se parecen. Veamos si logramos que se diferencien mirándolos de costado en varios cortes:

```{r 23419, message=FALSE}
ggplot(grid, aes(x1, pred, colour = x2, group = x2)) + 
  geom_line() +
  facet_wrap(~ model)

ggplot(grid, aes(x2, pred, colour = x1, group = x1)) + 
  geom_line() +
  facet_wrap(~ model)
```

Ponele que la interacción está justificada. HW dice que los residuos para el modelo 2 se ven sutilmente mejor y lo deja como ejercicio.

***

### Diciendole a R cómo transformar datos - ojo al piojo, habemus necesidad de truco

* En algunos casos vamos a hacer transformaciones dentro del modelo. Hay que tener algunos cuidados para indicarselo a R.

* Ejemplos:

`log(y) ~ sqrt(x1) + x2` es $log(y) = a_1 + a_2 * \sqrt{x_1} + a_3 * x_2$ 

*pero*

`y ~ x ^ 2 + x` es $y = a_1 + a_2 * x$

* Las transformaciones que involucran $+$, $*$, $^$ o $-$ hay que indicarlas con `I()`.

* Es así que $y = a_1 + a_2 * x + a_3 * x^2$ se indica `y ~ x + I(x ^ 2)`

* Ante la duda de cuál es la estructura de $x$ que está ajustando `lm()`, siempre puede venir `model_matrix()` al rescate:

```{r 23420, message=FALSE}
df <- tribble(
  ~y, ~x,
   1,  1,
   2,  2, 
   3,  3,
   4,  4
)
model_matrix(df, y ~ x^2 + x)
model_matrix(df, y ~ I(x^2) + x)
```

***

### Transformaciones polinomiales


* Gracias al teorema de Taylor, podemos usar un polinomio para a cualquier función suave.

* Un polinomio tiene esta pinta $y = a_1 + a_2 * x + a_3 * x^2 + a_4 * x^3$ y R nos puede ayudar a tipearla usando la función `poly()`  

```{r 23421, message=FALSE}
model_matrix(df, y ~ poly(x, 3))
```

* Fuera del rango de los datos, los polinomios se van rápido a $-\infty$ o $+\infty$. `splines::ns()` nos puede dar una mano para que esto no le ocurra a nuestras transformaciones

```{r 23422, message=FALSE}
library(splines)
model_matrix(df, y ~ ns(x, 3))
```

* Un ejemplo bonito, pero medio irrelevante para mi gusto, aproximar datos generados usando $y = 4*sen(x)$

```{r 23423, message=FALSE}
sim5 <- tibble(
  x = seq(0, 3.5 * pi, length = 50),
  y = 4 * sin(x) + rnorm(length(x))
)

ggplot(sim5, aes(x, y)) +
  geom_point()
```

Usando estos cinco modelos:

```{r 23424, message=FALSE}
mod1 <- lm(y ~ ns(x, 1), data = sim5)
mod2 <- lm(y ~ ns(x, 2), data = sim5)
mod3 <- lm(y ~ ns(x, 3), data = sim5)
mod4 <- lm(y ~ ns(x, 4), data = sim5)
mod5 <- lm(y ~ ns(x, 5), data = sim5)

grid <- sim5 %>% 
  data_grid(x = seq_range(x, n = 50, expand = 0.1)) %>% 
  gather_predictions(mod1, mod2, mod3, mod4, mod5, .pred = "y")

ggplot(sim5, aes(x, y)) + 
  geom_point() +
  geom_line(data = grid, colour = "red") +
  facet_wrap(~ model)
```

* Fuera del rango de los datos, es medio un desastre, pero está bien, porque no queremos usar el modelo cuando no hubo datos que lo respalden. En cualquier caso, extrapolar es una mala idea.


***

### Me faltan valores o valores faltantes

* Si tenés datos faltantes, no hay información para resumir en el modelo, por lo  cual el comportamiento por defecto de R es descartarlos.

* R lo hace en forma silente, a menos que especifiques `options(na.action = na.warm)` como hicimos al principio del capítulo.


```{r 2351, message=FALSE}
df <- tribble(
  ~x, ~y,
  1, 2.2,
  2, NA,
  3, 3.5,
  4, 8.3,
  NA, 10
)

mod <- lm(y ~ x, data = df)
```

Usando el argumento `na.action = na.exclude` lo podés sileanciar:

```{r 2352, message=FALSE}
mod <- lm(y ~ x, data = df, na.action = na.exclude)
```

y usando `nobs()` se puede saber cuántos datos usó el modelo para su ajuste:

```{r 2353, message=FALSE}
nobs(mod)
```

* De una forma u otra, siempre es bueno estar al tanto de si me faltan o no datos en mis ajustes

***

### Para un breve compendio de otros modelos posibles, más allá de los lineales, vean 23.6