---
title: "Capítulos 22 y 23"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

<br><br><br><br>

### **Capítulo 22:** Introducción a Modelado

<br><br><br><br>

###  Usted está _aquí_

![](figures\ch22_1.jpg)

***

### Generalidades

* El objetivo de un modelo es proveer un resumen de baja dimensión (poquitas variables) de una base de datos.

* Idealmente, un modelo:

1. Captura señales verdaderas (patrones generados por el fenómeno en estudio)

2. Ignora ruido (variación azarosa que no nos interesa)

* Vamos a estar viendo modelos predictivos (tambien se los nombra supervisados, ponele).


***

### Qué se incluye en este "Usted está aquí" de Modelado

* Capítulos 23 a 25 buscan construir la intuición de cómo funcionan estos modelos estadísticos.

* Modelado Básico (Capi 23, hoy): cuestiones mecánicas sobre modelos lineales usando datos simulados (no reales).

* Construcción de modelos (Capi 24, en dos domingos): formas para extraer patrones de datos reales.

* En el capítulo 25 vamos a ver muchos modelos simples para entender bases de datos complejas.

* Todos los contenidos serán sobre todo cualitativos (no habrá herramientas para cuantificar cuán bueno es un modelo).


***

### Conceptos claves importantes para la vida (datera)

* Cada observación puede ser usada para explorar los datos (análisis exploratorio, generación de hipótesis) o para confirmar una hipótesis (análisis inferencial) - *nunca ambas*.

* Usa tus observaciones tantas veces como quieras para explorar tus datos. Usála sólo una vez para confirmar algo.

* Tan pronto como usas un dato dos veces, acabás de pasar del marco confirmatorio al exploratorio (pero no hay warning de RStudio que te salve en esta).

* Si no usas distintos datos para generar una hipotesis y para confirmarlas, vas a pecar de optimista (sobreajuste)

* Si presentás un modelo exploratorio como uno confirmatorio vas a estar contribuyendo a la crisis de replicabilidad de la ciencia :-P


***

### Tips para no meter la pata en la vida (datera)

* Una forma  (de muchas) para no meter la pata es dividir tus datos en distintos conjuntos:

1. Set de entrenamiento (training, para exploración), quizás 60% de tus datos

2. Set para comparar modelos o visualizaciones en forma manual (query set). Para chequear algunas hipotesis generadas con el training set.

3. Set de prueba (testing set). Lo usarás sólo una vez, para poner a prueba el modelo final.

* Nota: igual un análisis descriptivo _siempre_ hay que hacerle al testing set.

<br><br><br><br>

### **Capítulo 23:** Modelado básico

<br><br><br><br>

###  Intro

* Vamos a usar modelos matemáticos para representar los datos como patrones y el resto, los residuales - que muchas veces solo representan ruido.

* En este capítulo se usarán solo datos simulados, simples y sin interés práctico, pero que ayudan a entender la esencia del modelado.

***

### El modelo y sus partes

* Parte 1: Familia de modelos. La expresamos en forma generica como, por ejemplo:

1. $y = a_1 * x + a_2$ (modelo lineal) o 
2. $y = a_1 * x ^ {a_2}$ (modelo no lineal)

En estos modelos $x$ e $y$ son columnas de nuestros datos tidy y $a_1$ y $a_2$ son parámetros que cambian para capturar distintos patrones en los datos.


* Parte 2: Modelo ajustado (fitted). El modelo de la familia que es más cercano a los datos (cercano definido de alguna forma, hay muchas formas). El modelo ajustado tiene formas específicas tales como:

1. $y = 3 * x + 7$ (modelo lineal) o 
2. $y = 9 * x ^ 2$ (modelo cuadrático)

El modelo ajustado es el modelo más cercano a los datos de toda la familia. Es el "mejor" modelo en cuanto a cercanía. Esto *nunca* implica que el modelo sea bueno o útil. Podrías tener el mejor de los peores.

***

Un modelo no busca revelar la verdad, si no descubrir una aproximación simple que sea útil.

***

### Paquete `modelr`

Este paquete anda lindo con funciones de modelado de R base y permite que usemos ` %>% `.

```{r 2311, message=FALSE}

library(tidyverse)

library(modelr)

options(na.action = na.warn)
```

***

### Un modelito tranca

```{r 232, message=FALSE}

ggplot(sim1, aes(x, y)) + # sim1 viene con modelr
  geom_point()
```

Que patron tiene este modelo lineal? (versión dominguera del color del caballo blanco de San Martín - sí, me tragué un payaso)

***

### Juguemos un toque a ver cómo podemos generar un modelo lineal

Es decir, un modelo de esta familia $y = a_0 + a_1 * x$.


```{r 2321, message=FALSE}

# armamos un tibble con la columna a1 y la columna a2 generadas al azar como dos variables uniformes, una va entre -20 y 40 y la otra entre -5 y 5 Al ser uniformes, la probabilidad de que salga cualquiera de los numeros en ese rango es la misma
models <- tibble(
  a1 = runif(250, -20, 40),
  a2 = runif(250, -5, 5)
)

# Al grafico de los puntos iniciales, le agregamos rectas al azar con ordenada al origen a1 y pendiente a2. Un bardito.
ggplot(sim1, aes(x, y)) + 
  geom_abline(aes(intercept = a1, slope = a2), data = models, alpha = 1/4) +
  geom_point() 

```
* Hay 250 líneas (modelos) en el gráfico, una por cada $a_1$ y $a_2$ generadas. 

* Hay un montón de líneas uqe no tienen nada que ver con los puntos de los datos `sim1`. 

* Qué significa exactamente estar cerca de los datos?

* Una forma de estar cerca podría ser encontrar la línea con $a_1$ y $a_2$ cuya distancia vertical a cada punto de `sim1` sea mínima. Como en esta figura (hay líneas torcidas para que se vean todas).

***

![](figures\ch23_1.jpg)
* La línea azul representa la diferencia entre el valor de $y$ dado por el modelo (predicción) y cada punto en `sim1`.

***

### Mínimos Cuadrados a Manopla

* Pocas cosas mejores que programar un método para entender de qué se trata. Vamos a tratar de encontrar la mejor línea usando código.

* *Paso 1.* usando dos posibles $a_1$ y $a_2$, generar predicciones para los 30 pares de datos en `sim1`.

```{r 2322, message=FALSE}

model1 <- function(a, data) {
  a[1] + data$x * a[2]
}
model1(c(7, 1.5), sim1)

```

* *Paso 2.* Calculamos las distancias entre cada punto en `sim1` y estas predicciones

* *Paso 3.* Colapsamos las 30 distancias en un solo número. Una forma matemáticamente bonita y conveniente de hacerlo es elevando cada diferencia al cuadrado y tomando el promedio de la suma de esos cuadrados y sacando la raíz cuadrada de ese promedio (error cuadrático medio)

```{r 2323, message=FALSE}

measure_distance <- function(mod, data) {
  diff <- data$y - model1(mod, data)
  sqrt(mean(diff ^ 2))
}
measure_distance(c(7, 1.5), sim1)
```

* *Paso 4.* Repetimos 1 a 3 para cada uno de los 250 modelos que generamos en `models`

```{r 2324, message=FALSE}

sim1_dist <- function(a1, a2) {
  measure_distance(c(a1, a2), sim1)
}

# usamos purrr con la helper function sim1_dist que toma 2 parametros double
models <- models %>% 
  mutate(dist = purrr::map2_dbl(a1, a2, sim1_dist))
models
```

* *Paso 5, primer intento.* Queremos encontrar la mejor recta (la más cercana a los datos) veamos qué pinta tienen los 10 modelos con menor `dist`


```{r 2325, message=FALSE}

ggplot(sim1, aes(x, y)) + 
  geom_point(size = 2, colour = "grey30") + 
  geom_abline(
    aes(intercept = a1, slope = a2, colour = -dist), 
    data = filter(models, rank(dist) <= 10)
  )
```

* *Paso 5, segundo intento.* También podemos graficar todas los pares $a_1$ y $a_2$, colorear por `-dist` y marcar los 10 pares con la menor `dist`

```{r 2326, message=FALSE}

ggplot(models, aes(a1, a2)) +
  geom_point(data = filter(models, rank(dist) <= 10), size = 4, colour = "red") +
  geom_point(aes(colour = -dist))
```

* *Paso 5, mejorado.* Combinamos el Paso 4 y el 5 pero en lugar de hacerlo con modelos al azar, lo hacemos de una forma sistemática buscando los parámetros en una grilla de parámetros distribuidos uniformemente (grid search).

```{r 2327, message=FALSE}

# los parametros para la grilla salen de mirar el grafico anterior y ver donde estaban los mejores parámetros
# expand.grid es una funcion de R base que crea un dataframe de todas las combinaciones de dos factores
grid <- expand.grid(
  a1 = seq(-5, 20, length = 25),
  a2 = seq(1, 3, length = 25)
  ) %>% 
  mutate(dist = purrr::map2_dbl(a1, a2, sim1_dist))

grid %>% 
  ggplot(aes(a1, a2)) +
  geom_point(data = filter(grid, rank(dist) <= 10), size = 4, colour = "red") +
  geom_point(aes(colour = -dist)) 

```

Cómo les va con los datos a estos 10 mejores pares de parámetros?

```{r 2328, message=FALSE}

ggplot(sim1, aes(x, y)) + 
  geom_point(size = 2, colour = "grey30") + 
  geom_abline(
    aes(intercept = a1, slope = a2, colour = -dist), 
    data = filter(grid, rank(dist) <= 10)
  )

```

* *Paso 5, intento final.* Podrías repetir el intento final haciendo la grilla cada vez más fina hasta que encontrás el mejor modelo. Hay un algoritmo que lo hace llamado búsqueda de Newto-Raphson y que está implementado en la funcion `optim()` del paquete `stats` en R base.

```{r 2329, message=FALSE}

best <- optim(c(0, 0), measure_distance, data = sim1)
best$par

ggplot(sim1, aes(x, y)) + 
  geom_point(size = 2, colour = "grey30") + 
  geom_abline(intercept = best$par[1], slope = best$par[2])
```

La intuicion detras de `optim()` es que si tenes:

* una función que define la distancia entre un modelo 
* un set de datos 
* un algoritmo que puede minimizar la distancia modificando los parámetros del modelo

podés encontrar el mejor modelo. 

La belleza de esto es que esto lo podés usar para cualquier familia de modelos para los que puedas escribir una ecuación.

* *Paso 5, intento final usando matemática.* $y = a_1 + a_2 * x$ es un modelo lineal y en estos casos R tiene la función `lm()` para ajustarlo

```{r 23210, message=FALSE}
# lm() usa formulas, en este caso y ~ x es la forma de escribir y = a_1 + a_2 * x
sim1_mod <- lm(y ~ x, data = sim1)
coef(sim1_mod)
```

Obtenemos al segundo decimal lo mismo que con `optim()`.  `lm()` es mucho mas rapido y mejor porque resuelve todo en un solo paso y garantiza que encuentra el mejor modelo. Usa una formula matematica que se puede derivar para los modelos lineales. La mayoria de los modelos no tienen estas formulas o a veces calcularlas es dificil y se termina usando algo como `optim()`.

***

### Visualizando un modelo a través de sus predicciones


* Mirar un modelo a través de sus predicciones tiene la ventaja de que lo podés hacer para cualquier modelo predictivo - incluso los que tienen ecuaciones difíciles de dibujar en dos o tres dimensiones.

* Usando `modelr::data_grid()` se puede generar una grilla de valores que cubra la region donde viven los datos que observamos - en este caso `sim1`

```{r 2331, message=FALSE}
grid <- sim1 %>% 
  data_grid(x) 
grid
```

La salida es mucho mas interesante cuando tenemos mas variables en nuestro modelo.

A esta grilla le agregamos predicciones usando `modelr::add_predictions()` usando el modelo `sim1_mod`.

```{r 2332, message=FALSE}
grid <- grid %>% 
  add_predictions(sim1_mod) 
grid
```

Y ahora podemos graficar las predicciones sobre nuestros datos originales.

```{r 2333, message=FALSE}
ggplot(sim1, aes(x)) +
  geom_point(aes(y = y)) +
  geom_line(aes(y = pred), data = grid, colour = "red", size = 1)
```

Pará, pará, pará... pero no es más fácil hacerlo con `geom_abline()`? Sí, cuando tu modelo tiene una ordenada al origen y una pendiente, pero modelos más complicados no tienen sólo dos parámetros, tienen un montón. Siempre podés visualizar sus predicciones y ver cómo funcionan para tus datos.

***

### Visualizando un modelo a través de sus residuos

* La otra cara de las predicciones son los residuales.

* Las predicciones nos dicen qué patrones capturó el modelo.

* Los residuales nos dicen qué patrones no capturó.

* Son las distancia entre los datos observados y los valores predichos por el modelo.

* Si nuestro modelo capturó todos los patrones, los residuales no deberían mostrarnos ningún patrón y estar, en promedio cerca de 0 y no muy lejos de los valores observados.

```{r 2334, message=FALSE}
# add_residuals de modelr agrega residuales
sim1 <- sim1 %>% 
  add_residuals(sim1_mod)
sim1
```

Con un polígono de frecuencias podemos entender cómo se distribuyen los residuales.

```{r 2335, message=FALSE}
ggplot(sim1, aes(resid)) + 
  geom_freqpoly(binwidth = 0.5)
```

Otra forma de ver los residuales es ver cómo se relacionan con los predictores en nuestro modelo.

```{r 2336, message=FALSE}
ggplot(sim1, aes(x, resid)) + 
  geom_ref_line(h = 0) +
  geom_point()
```

Si hay ningún patrón cuando graficamos los predictores en funcion de los residuos, quiere decir que no nos quedaron patrones por aprender y que el modelo que tenemos capturó toda la información que había en los datos.
 

***

### Un chapuzón al mundo de las fórmulas en R

* Las fórmulas en R, esos enunciados que incluyen un `~`, nos ofrecen una forma de capturar la estructura de variables que las funciones de R pueden interpretar.

* Para ver qué es lo que R hace realmente cuando le decimos `y ~ x` para representar $y = a_1 + a_2 * x$, podemos usar `modelr::model_matrix()`.

```{r 2341, message=FALSE}
df <- tribble(
  ~y, ~x1, ~x2,
  4, 2, 5,
  5, 1, 6
)
model_matrix(df, y ~ x1 + x2)
```

* Notá que para representar la ordenada al origen, R agrega una columna de unos. Si no la querés, hay que pedirle explícitamente que la saque usando `-1`.

```{r 2342, message=FALSE}
model_matrix(df, y ~ x1 + x2 - 1)
```

***

### Fórmulas con variables categóricas - angora te quiero ver

* A la hora de las fórmulas las variables categóricas nos pueden complicar un poco la existencia, comparadas con la papa que son las variables continuas.

* Las variables categóricas no son números, no tiene sentido multiplicarlas. A ver, no tiene sentido algo del estilo $y = x_0 + x_1 * color$ donde `color` toma los valores verde y violeta. Un número multiplicado por verde no nos va a dar un número para $y$. 

* Lo que hace R es convertir $y = x_0 + x_1 * color$ a $y = x_0 + x_1 * colorvioleta$, en donde `colorvioleta` es 1 si `color` es violeta y 0 si no.

```{r 2343, message=FALSE}
df <- tribble(
  ~ color, ~ response,
  "verde", 1,
  "violeta", 2,
  "verde", 1
)
model_matrix(df, response ~ color)
```

* Y por qué no ponemos una columna `colorverde` también? Porque agregamos información redundante - $ colorverde = 1 - colorvioleta$, si sabemos el valor de `colorvioleta` deducimos, sin info extra, el valor de `colorverde`.

* Al agregar info redundante la estimación de nuestros $x_0$ y $x_1$ no va a ser único y se nos complica la vida al pepe.

***

### Modelo lineal con una predictora categórica con cuatro valores posibles (o niveles)

```{r 2344, message=FALSE}
# la base sim2 es de modelr
ggplot(sim2) + 
  geom_point(aes(x, y))
```

R usa la siguiente matriz para x (xb, xc, xd - 4 categorias menos 1):

```{r 2347, message=FALSE}
model_matrix(sim2, y ~ x)
```

Le ajustamos un modelo lineal a `sim2` y vemos sus predicciones:

```{r 2345, message=FALSE}
mod2 <- lm(y ~ x, data = sim2)

grid <- sim2 %>% 
  data_grid(x) %>% 
  add_predictions(mod2)
grid
```

El modelo lineal predice la media de cada categoría de $x$ porque la media minimiza el error cuadrático medio. No es magia, es matemática.

```{r 2346, message=FALSE}
ggplot(sim2, aes(x)) + 
  geom_point(aes(y = y)) +
  geom_point(data = grid, aes(y = pred), colour = "red", size = 4)
```

Ojo con querer hacerle predecir para una clase de la categoría que no estaba en los datos originales:

```{r 2348, message=FALSE}
tibble(x = "e") %>% 
  add_predictions(mod2)
```
